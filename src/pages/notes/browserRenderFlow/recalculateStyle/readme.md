# 样式计算（computed Style）

样式计算时遍历DOMTree，将每个节点的根据CSSOM提供的样式，经过样式计算（computed Style）后将dom数的每个节点都带上计算过后最终的所有的CSS属性值  
在这个过程中，很多相对单位会变成绝对单位、例如em等变成px  

## 样式计算前提

**我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式**，样式计算的过程实际上就是把每个元素的每一个css属性按照一定规则补充完整的过程

## 具体步骤

### 确定声明值

首先是样式计算过程的第一步，确定声明值。所谓声明值，就是开发着自己写的样式或者说在样式表中能够找到的样式。例如：  

```css
div {
  background-color: red;
}
```

假设我们写了如上代码，就表示我们对div标签增加了一个声明值，声明了背景颜色是红色。然后把所有的声明值都收集，就是第一步确定声明值的过程

## 层叠

我们在确定声明值的过程中，大部分情况会出现冲突的情况，还是以上代码为例，假设在其他地方出现了如下的CSS样式：  

```css
div {
  background-color: green;
}
```

这明显就有了冲突，而层叠这一步，就是解决冲突的过程。  
在我能找到的很多关于各种浏览器是如何解决CSS冲突的资料中，大多都只笼统的介绍了CSS选择器的优先级，这是不准确和不完整的。  
我了解到的完整的冲突解决的方法主要是按照以下三步来走，走完即可确认生效的是哪一条，然后这个完成流程叫做层叠
具体步骤如下：  

- 比较源的重要性（也有说法只把这一步叫做层叠）
- 比较优先级
- 比较次序

接下来一步一步的说明

### 比较源的重要性

当不同来源的CSS样式拥有了相同的声明，此时就会根据来源的重要性来确定到底采用哪一个声明。  
我们的样式表来源主要有以下几种：  

- **用户代理样式**，也称作浏览器默认样式  
  我们从浏览器调试工具的elements标签查看styles时，通常会看到如下来源的样式：  

  ![用户代理样式表](/src/assets/browserRender/user_agent_stylesheet_demo.jpg)

  这就是用户代理样式

- **页面作者样式**，这个就非常简单，就是开发者写的样式
- 浏览器的用户自定义的定制样式，可以称之为**用户样式（也叫做读者样式）**  
  这个可能比较难理解，其实可以理解为浏览器设置（或者插件）里面可以调整的一些关于UI的设置，很多最终实际上是生成了一个用户样式表，通过CSS的方式影响页面效果

一般情况，对应的重要性顺序是 **页面作者样式** > **用户样式** > **用户代理样式**

详细一点的表格如下：  

|   | 来源     | 重要程度    |
|---|----------|-------------|
| 1 | 用户代理 | 普通        |
| 2 | 用户     | 普通        |
| 3 | 页面作者 | 普通        |
| 4 | CSS动画  | 见特殊说明  |
| 5 | 页面作者 | !important |
| 6 | 用户     | !important |
| 7 | 用户代理 | !important |
| 8 | CSS过渡  |             |

优先级从上往下依次升高，通常情况下用户代理和用户的样式表中很少会存在!important，所以通常情况下页面作者的!important就是重要性最高的样式表  

然后特别说明下CSS动画。  
对于CSS动画来说，首先@keyframe是不参与层叠的。然后如果有多个满足条件的keyframe,将会是重要性最高的来源样式中最后的一个生效，而不是讲他们组合到一起。同时@keyframe定义的值依然会被!important覆盖

最后，详细的层叠规则，请参考这个文档[https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)

### 比较优先级

但是我们作为开发者，更多时候遇到的问题是都是同一来源的（通常就是页面作者样式来源）的声明发生了冲突，那这个时候就需要进行层叠的第二步，比较优先级。  

这个优先级比较规则就是我们经常搜到的CSS选择器优先级的部分，可见那些资料中对CSS样式计算的描述只是其中的很小一部分。

优先级的比较我认为可以总结为一句话：**!important最高，内联其次。然后就是越具体越高**。  
但是他们能互相组合，情况还是比较多的。我们可以通过两种情况看一下css选择器的优先级。  

- IDE（VSCode为例）自带的工具，鼠标放到某个css的选择器上时：  

![CSS优先级](/src/assets/browserRender/css_priority.jpg)  

其中选择器特性就是优先级的说明，他是三个数字，从左到右分别是ID选择器权重值、类（包含伪类、属性）选择器权重值、元素选择器权重值。  

比较方法就是从左到右比较，前一个比较出结果后续的就不再比较，前一个相同比较后一个值大小。  

具体的优先级规则可以参考这个文档[https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)  

但是我更建议结合这个图(图片点击可跳转到对应网页):  

[![css优先级](/src/assets/browserRender/css_specifushity.jpg)](https://specifishity.com/)  

能够更形象的理解css选择器的优先级

最后，在浏览器中的调试工具中，优先级低的声明，会被划上中横线表示无效  
![css优先级](/src/assets/browserRender/css_priority_demo.png)

### 比较次序

在我们开发过程中，还会遇到来源相同、优先级相同的css样式声明发生冲突，当遇到这样的情况，就只有再通过比较声明的次序这个步骤角逐最后胜利的那位。

这个就很简单，看看最后的浏览器拿到的css代码，后面的覆盖前面的  

假设存在以下代码：  

```css
h1 {
  font-size: 50px;
}

h1 {
  font-size: 20px;
}
```

最后会得到如下结果：  
![css声明次序](/src//assets/browserRender/css_order.png)

## 继承

层叠步骤结束，所有声明了的css属性都有了值，那么对于没有声明的CSS，首先使用继承规则看能否继承值。能继承的使用继承而来的值，没法继承的，再考虑下一步。  

说到继承，就要解决两个问题：  

### 从何处继承

对于CSS属性来说，从何处继承这个规则就想对简单得多，以一句话总结就是：**父元素上继承（没有就向上一直查找），谁近听谁的**  

从父元素继承这句话很好理解，但是谁近听谁的这个就需要稍微解释下，就是继承不涉及CSS选择器优先级的规则，因为当前元素的当前考虑继承的属性都没有任何选择器对他进行声明了，既然都没有选择器，自然也就无需考虑CSS选择器的优先级规则。  

举个列子，存在如下的代码：  

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>test</title>
</head>
<style>
  div {
    color: red;
  }
  .test {
    color: green;
  }
</style>
<body>
  <div class="test">
    <div>
      <p>test</p>
    </div>
  </div>
</body>
</html>
```

我们从代码中可以看到，dom结构很简单，一个div.test标签包含了一个普通的div标签，普通div标签再包含了一个p标签。  

然后此时我们讨论p标签的color这个属性：  

1. 首先是没有任何地方声明了P标签的color属性，包括用户代理样式表，所以P标签的color属性会先尝试继承。
2. 继承从父元素继承，父元素是普通div
3. 普通的div中有对他声明的color属性，属性值是red,就近就找到了。得到了继承而来的值是red;
4. 将此处p标签的color属性的值设置为继承而来的red，运行代码结果入下：  
  ![css属性继承](/src/assets/browserRender/css_extends_1.png)

很多人可能会有如此的疑惑，应该是.test的优先级更高，不应该是继承这个.test的值green吗？这就想错了，继承没有优先级的说法，仅仅只是单纯的看父元素有没有这个属性的声明，有就用，没有继续往上找。  

此处p的父元素有color属性的声明，那就直接使用，不用考虑他的优先级是否有父元素的父元素的.test的优先级高。

当然，如果我们改一下代码，删掉下面这段代码：  

```css
div {
  color: red;
}
```

这个时候p元素的color就会是green，因为p的父元素的div并没有color的声明，p的爷爷上能找到color的声明，值是green，所以p的color值就是green。  

或者也可以这样理解，p去父元素div里面没找到color,父div就启动他的继承规则，他又去他的父亲div.test里面找，找到了green，所以普通div本身的color是继承来的green，p又从父元素这边继承了父元素从div.test处继承而来的green

### 哪些属性可以继承

解决了从何处继承，还要知道哪些属性可以继承，这个的话就不一一列举了，具体情况请去MDN上搜索具体的CSS属性，会标明是否可以继承。常见的color、font-size等都可以继承

## 使用默认值

经过声明值确认、层叠、继承过后，dom元素如果还有CSS属性没有值（这是大概率的，因为CSS属性太多了，我们经常使用的只是其中很小一部分），那最后就只能使用默认值。  

默认值在MDN的具体CSS属性文档里也能看到，同时我们也能通过这个地方看到一个dom原生所有的css属性值包含哪些：  

![css默认值](/src/assets/browserRender/css_default_value.png)

至此，一个dom元素的样式计算过程就完成了，这个dom元素也最终得到了一个包含所有CSS属性的样式信息。
